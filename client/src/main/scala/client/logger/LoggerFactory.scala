package client.logger
import scala.annotation.elidable
import scala.annotation.elidable._
trait Logger {
 /*
  * Use @elidable annotation to completely exclude functions from the compiler generated byte-code based on
  * the specified level. In a production build most logging functions will simply disappear with no runtime
  * performance penalty.
  *
  * Specify level as a compiler parameter
  * > scalac -Xelide-below INFO
 */
 @elidable(FINEST) def trace(msg: String, e: Exception): Unit
 @elidable(FINEST) def trace(msg: String): Unit
 @elidable(FINE) def debug(msg: String, e: Exception): Unit
 @elidable(FINE) def debug(msg: String): Unit
 @elidable(INFO) def info(msg: String, e: Exception): Unit
 @elidable(INFO) def info(msg: String): Unit
 @elidable(WARNING) def warn(msg: String, e: Exception): Unit
 @elidable(WARNING) def warn(msg: String): Unit
 @elidable(SEVERE) def error(msg: String, e: Exception): Unit
 @elidable(SEVERE) def error(msg: String): Unit
 @elidable(SEVERE) def fatal(msg: String, e: Exception): Unit
 @elidable(SEVERE) def fatal(msg: String): Unit
 def enableServerLogging(url: String): Unit
 def disableServerLogging(): Unit
 /* Kestrel-like calls to avoid creating local variables in client code where the local variables would be there
  * solely to carry the value past the log statement */
 //TODO just translate levels in Scala to avoid all this duplication?
 //def trace[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {trace(msg, e); t}
 def trace[T](t: T, msg: String, ft: T => String = empty): T = {trace(combine(t, msg, ft)); t}
 //def debug[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {debug(combine(t, msg, ft), e); t}
 def debug[T](t: T, msg: String, ft: T => String = empty): T = {debug(combine(t, msg, ft)); t}
 //def info[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {info(combine(t, msg, ft), e); t}
 def info[T](t: T, msg: String, ft: T => String = empty): T = {info(combine(t, msg, ft)); t}
 //def warn[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {warn(combine(t, msg, ft), e); t}
 def warn[T](t: T, msg: String, ft: T => String = empty): T = {warn(combine(t, msg, ft)); t}
 //def error[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {error(combine(t, msg, ft), e); t}
 def error[T](t: T, msg: String, ft: T => String = empty): T = {error(combine(t, msg, ft)); t}
 //def fatal[T](t: T, msg: String, e: Exception, ft: T => String = empty): T = {fatal(combine(t, msg, ft), e); t}
 def fatal[T](t: T, msg: String, ft: T => String = empty): T = {fatal(combine(t, msg, ft)); t}
 private def combine[T](t: T, msg: String, ft: T => String) = {
  val tPart = ft(t)
  msg + (if (msg.trim.nonEmpty && tPart.trim.nonEmpty) " " else "") + tPart
 }
 private def empty: Any => String = _ => ""
}
object LoggerFactory {
 private[logger] def createLogger(name: String) = {}
 lazy val consoleAppender = new BrowserConsoleAppender
 lazy val popupAppender = new PopUpAppender
 /**
   * Create a logger that outputs to browser console
   */
 def getLogger(name: String): Logger = {
  val nativeLogger = Log4JavaScript.log4javascript.getLogger(name)
  nativeLogger.addAppender(consoleAppender)
  consoleAppender.setThreshold(Level42.DEBUG)
  new L4JSLogger(nativeLogger)
 }
 /**
   * Create a logger that outputs to a separate popup window
   */
 def getPopUpLogger(name: String): Logger = {
  val nativeLogger = Log4JavaScript.log4javascript.getLogger(name)
  nativeLogger.addAppender(popupAppender)
  new L4JSLogger(nativeLogger)
 }
}
